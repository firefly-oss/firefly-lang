/**
 * Option Type - Safe handling of optional values
 * 
 * The Option type represents an optional value: every Option is either Some and contains a value,
 * or None, and does not. Option types are very common in Firefly code, as they have a number of uses:
 * 
 * - Initial values
 * - Return values for functions that are not defined over their entire input range (partial functions)
 * - Return value for otherwise reporting simple errors, where None is returned on error
 * - Optional struct fields
 * - Optional function arguments
 * 
 * Options are commonly paired with pattern matching to query the presence of a value and take action,
 * always accounting for the None case.
 * 
 * @package firefly::std::option
 * @version 1.0.0
 * @author Firefly Standard Library Team
 */
module firefly::std::option

/**
 * The Option type. See the module level documentation for more.
 * Â£
 * @type Option<T>
 * @variant Some(T) - Some value of type T
 * @variant None - No value
 */
data Option<T> {
    Some(T),
    None
}

// ============================================================================
// Constructors
// ============================================================================

/**
 * Creates a Some variant containing the given value.
 * 
 * @param value The value to wrap in Some
 * @return Option<T> containing the value
 * 
 * @example
 *   let x = some(42)  // Some(42)
 */
fn some<T>(value: T) -> Option<T> = Some(value)

/**
 * Creates a None variant.
 * 
 * @return Option<T> representing no value
 * 
 * @example
 *   let x: Option<Int> = optionNone()  // None
 */
fn optionNone<T>() -> Option<T> = None

// ============================================================================
// Querying the variant
// ============================================================================

/**
 * Returns true if the option is a Some value.
 * 
 * @param opt The option to check
 * @return true if Some, false if None
 * 
 * @example
 *   isSome(Some(42))  // true
 *   isSome(None)      // false
 */
fn isSome<T>(opt: Option<T>) -> Bool = match opt {
    Some(_) => true,
    None => false
}

/**
 * Returns true if the option is None.
 * 
 * @param opt The option to check
 * @return true if None, false if Some
 * 
 * @example
 *   isNone(Some(42))  // false
 *   isNone(None)      // true
 */
fn isNone<T>(opt: Option<T>) -> Bool = match opt {
    Some(_) => false,
    None => true
}

// ============================================================================
// Extracting the contained value
// ============================================================================

/**
 * Returns the contained Some value.
 * 
 * @param opt The option to unwrap
 * @return The contained value
 * @throws Panics if the value is None
 * 
 * @example
 *   unwrap(Some(42))  // 42
 *   unwrap(None)      // panics!
 */
fn unwrap<T>(opt: Option<T>) -> T = match opt {
    Some(value) => value,
    None => error("Called unwrap on None")
}

/**
 * Returns the contained Some value or a provided default.
 * 
 * @param opt The option to unwrap
 * @param default The default value to return if None
 * @return The contained value or default
 * 
 * @example
 *   unwrapOr(Some(42), 0)  // 42
 *   unwrapOr(None, 0)      // 0
 */
fn unwrapOr<T>(opt: Option<T>, default: T) -> T = match opt {
    Some(value) => value,
    None => default
}

/**
 * Returns the contained Some value or computes it from a closure.
 * 
 * @param opt The option to unwrap
 * @param f Function to compute default value
 * @return The contained value or computed default
 * 
 * @example
 *   unwrapOrElse(Some(42), || 0)  // 42
 *   unwrapOrElse(None, || 0)      // 0
 */
fn unwrapOrElse<T>(opt: Option<T>, f: () -> T) -> T = match opt {
    Some(value) => value,
    None => f()
}

// ============================================================================
// Transforming contained values
// ============================================================================

/**
 * Maps an Option<T> to Option<U> by applying a function to a contained value.
 * 
 * @param opt The option to map
 * @param f The function to apply
 * @return Option<U> with the function applied, or None
 * 
 * @example
 *   map(Some(42), |x| x * 2)  // Some(84)
 *   map(None, |x| x * 2)      // None
 */
fn map<T, U>(opt: Option<T>, f: (T) -> U) -> Option<U> = match opt {
    Some(value) => Some(f(value)),
    None => None
}

/**
 * Applies a function to the contained value (if any), or returns the provided default (if not).
 * 
 * @param opt The option to map
 * @param default The default value
 * @param f The function to apply
 * @return The result of f or default
 * 
 * @example
 *   mapOr(Some(42), 0, |x| x * 2)  // 84
 *   mapOr(None, 0, |x| x * 2)      // 0
 */
fn mapOr<T, U>(opt: Option<T>, default: U, f: (T) -> U) -> U = match opt {
    Some(value) => f(value),
    None => default
}

/**
 * Applies a function to the contained value (if any), or computes a default (if not).
 * 
 * @param opt The option to map
 * @param defaultFn Function to compute default
 * @param f The function to apply
 * @return The result of f or defaultFn
 * 
 * @example
 *   mapOrElse(Some(42), || 0, |x| x * 2)  // 84
 *   mapOrElse(None, || 0, |x| x * 2)      // 0
 */
fn mapOrElse<T, U>(opt: Option<T>, defaultFn: () -> U, f: (T) -> U) -> U = match opt {
    Some(value) => f(value),
    None => defaultFn()
}

// ============================================================================
// Boolean operations
// ============================================================================

/**
 * Returns None if the option is None, otherwise calls f with the wrapped value and returns the result.
 * 
 * @param opt The option to flat map
 * @param f The function to apply
 * @return The result of f or None
 * 
 * @example
 *   flatMap(Some(42), |x| Some(x * 2))  // Some(84)
 *   flatMap(None, |x| Some(x * 2))      // None
 */
fn flatMap<T, U>(opt: Option<T>, f: (T) -> Option<U>) -> Option<U> = match opt {
    Some(value) => f(value),
    None => None
}

/**
 * Returns None if the option is None, otherwise calls predicate with the wrapped value and returns:
 * - Some(t) if predicate returns true (where t is the wrapped value)
 * - None if predicate returns false
 * 
 * @param opt The option to filter
 * @param predicate The predicate function
 * @return Some if predicate is true, None otherwise
 * 
 * @example
 *   filter(Some(42), |x| x > 40)  // Some(42)
 *   filter(Some(42), |x| x > 50)  // None
 */
fn filter<T>(opt: Option<T>, predicate: (T) -> Bool) -> Option<T> = match opt {
    Some(value) => {
        if predicate(value) {
            Some(value)
        } else {
            None
        }
    },
    None => None
}

/**
 * Returns the option if it contains a value, otherwise returns other.
 * 
 * @param opt The first option
 * @param other The alternative option
 * @return opt if Some, otherwise other
 * 
 * @example
 *   or(Some(42), Some(100))  // Some(42)
 *   or(None, Some(100))      // Some(100)
 */
fn or<T>(opt: Option<T>, other: Option<T>) -> Option<T> = match opt {
    Some(_) => opt,
    None => other
}

/**
 * Returns the option if it contains a value, otherwise calls f and returns the result.
 * 
 * @param opt The first option
 * @param f Function to compute alternative
 * @return opt if Some, otherwise result of f
 */
fn orElse<T>(opt: Option<T>, f: () -> Option<T>) -> Option<T> = match opt {
    Some(_) => opt,
    None => f()
}

/**
 * Returns Some if exactly one of opt1, opt2 is Some, otherwise returns None.
 *
 * @param opt1 The first option
 * @param opt2 The second option
 * @return Some if exactly one is Some, None otherwise
 */
fn xor<T>(opt1: Option<T>, opt2: Option<T>) -> Option<T> =
    match opt1 {
        Some(_) => match opt2 {
            Some(_) => None,
            None => opt1
        },
        None => opt2
    }

// ============================================================================
// Combining options
// ============================================================================

/**
 * Zips two options into a single option of a tuple.
 *
 * @param opt1 The first option
 * @param opt2 The second option
 * @return Some((a, b)) if both are Some, None otherwise
 *
 * @example
 *   zip(Some(1), Some("hello"))  // Some((1, "hello"))
 *   zip(Some(1), None)           // None
 */
fn zip<T, U>(opt1: Option<T>, opt2: Option<U>) -> Option<(T, U)> =
    match opt1 {
        Some(a) => match opt2 {
            Some(b) => Some((a, b)),
            None => None
        },
        None => None
    }

/**
 * Applies a function to the values of two options.
 *
 * @param opt1 The first option
 * @param opt2 The second option
 * @param f The function to apply
 * @return Some(f(a, b)) if both are Some, None otherwise
 *
 * @example
 *   zipWith(Some(2), Some(3), |x, y| x + y)  // Some(5)
 *   zipWith(Some(2), None, |x, y| x + y)     // None
 */
fn zipWith<T, U, V>(opt1: Option<T>, opt2: Option<U>, f: (T, U) -> V) -> Option<V> =
    match opt1 {
        Some(a) => match opt2 {
            Some(b) => Some(f(a, b)),
            None => None
        },
        None => None
    }

/**
 * Flattens an Option<Option<T>> into Option<T>.
 *
 * @param opt The nested option
 * @return The flattened option
 *
 * @example
 *   flatten(Some(Some(42)))  // Some(42)
 *   flatten(Some(None))      // None
 *   flatten(None)            // None
 */
fn flatten<T>(opt: Option<Option<T> >) -> Option<T> = match opt {
    Some(inner) => inner,
    None => None
}

// ============================================================================
// Pattern matching helpers
// ============================================================================

/**
 * Executes one of two functions based on the option variant.
 *
 * @param opt The option to match
 * @param ifNone Function to execute if None
 * @param ifSome Function to execute if Some
 * @return The result of the executed function
 *
 * @example
 *   fold(Some(42), || 0, |x| x * 2)  // 84
 *   fold(None, || 0, |x| x * 2)      // 0
 */
fn fold<T, U>(opt: Option<T>, ifNone: () -> U, ifSome: (T) -> U) -> U = match opt {
    Some(value) => ifSome(value),
    None => ifNone()
}

