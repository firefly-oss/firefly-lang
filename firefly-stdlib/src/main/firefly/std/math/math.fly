/**
 * Math Utilities Module
 *
 * Professional mathematical functions library for Firefly.
 * Provides essential mathematical operations.
 *
 * This module demonstrates the full power of Firefly's language features:
 * - Mutable variables for iterative algorithms
 * - While loops for complex computations
 * - Conditional expressions for control flow
 * - Recursion for mathematical functions
 *
 * @module firefly::std::math
 * @since 1.0.0
 */

module firefly::std::math

/**
 * Returns the absolute value of an integer.
 *
 * @param x The integer value
 * @return The absolute value
 *
 * @example
 *   abs(-5) // 5
 *   abs(3) // 3
 */
fn abs(x: Int) -> Int = if x < 0 { -x } else { x }

/**
 * Returns the sign of an integer (-1, 0, or 1).
 *
 * @param x The integer value
 * @return -1 if negative, 0 if zero, 1 if positive
 *
 * @example
 *   sign(-5) // -1
 *   sign(0) // 0
 *   sign(3) // 1
 */
fn sign(x: Int) -> Int = {
    if x < 0 {
        -1
    } else {
        if x > 0 {
            1
        } else {
            0
        }
    }
}

/**
 * Returns the maximum of two integers.
 *
 * @param a The first integer
 * @param b The second integer
 * @return The larger value
 *
 * @example
 *   max(5, 3) // 5
 *   max(-2, -5) // -2
 */
fn max(a: Int, b: Int) -> Int = if a > b { a } else { b }

/**
 * Returns the minimum of two integers.
 *
 * @param a The first integer
 * @param b The second integer
 * @return The smaller value
 *
 * @example
 *   min(5, 3) // 3
 *   min(-2, -5) // -5
 */
fn min(a: Int, b: Int) -> Int = if a < b { a } else { b }

/**
 * Clamps an integer value between a minimum and maximum.
 *
 * @param value The value to clamp
 * @param minimum The minimum allowed value
 * @param maximum The maximum allowed value
 * @return The clamped value
 *
 * @example
 *   clamp(15, 0, 10) // 10
 *   clamp(-5, 0, 10) // 0
 *   clamp(5, 0, 10) // 5
 */
fn clamp(value: Int, minimum: Int, maximum: Int) -> Int =
    max(minimum, min(maximum, value))

/**
 * Computes the power of a base raised to an exponent using fast exponentiation.
 *
 * @param base The base value
 * @param exponent The exponent (must be non-negative)
 * @return base^exponent
 *
 * @example
 *   pow(2, 10) // 1024
 *   pow(5, 3) // 125
 */
fn pow(base: Int, exponent: Int) -> Int = {
    if exponent == 0 {
        1
    } else {
        if exponent < 0 {
            0
        } else {
            let mut result = 1;
            let mut exp = exponent;
            let mut b = base;
            while exp > 0 {
                if exp % 2 == 1 {
                    result = result * b
                } else {
                    result = result
                };
                b = b * b;
                exp = exp / 2
            };
            result
        }
    }
}

/**
 * Computes the greatest common divisor using Euclid's algorithm.
 *
 * @param a The first integer
 * @param b The second integer
 * @return The GCD of a and b
 *
 * @example
 *   gcd(48, 18) // 6
 *   gcd(100, 35) // 5
 */
fn gcd(a: Int, b: Int) -> Int = {
    let mut x = abs(a);
    let mut y = abs(b);
    while y != 0 {
        let temp = y;
        y = x % y;
        x = temp
    };
    x
}

/**
 * Computes the least common multiple.
 *
 * @param a The first integer
 * @param b The second integer
 * @return The LCM of a and b
 *
 * @example
 *   lcm(12, 18) // 36
 *   lcm(4, 6) // 12
 */
fn lcm(a: Int, b: Int) -> Int = {
    if a == 0 {
        0
    } else {
        if b == 0 {
            0
        } else {
            abs(a * b) / gcd(a, b)
        }
    }
}

/**
 * Computes the factorial of a non-negative integer.
 *
 * @param n The integer (must be >= 0)
 * @return n! = n * (n-1) * ... * 2 * 1
 *
 * @example
 *   factorial(5) // 120
 *   factorial(0) // 1
 */
fn factorial(n: Int) -> Int = {
    if n < 0 {
        0
    } else {
        if n == 0 {
            1
        } else {
            if n == 1 {
                1
            } else {
                let mut result = 1;
                let mut i = 2;
                while i <= n {
                    result = result * i;
                    i = i + 1
                };
                result
            }
        }
    }
}

/**
 * Computes the nth Fibonacci number.
 *
 * @param n The index (must be >= 0)
 * @return The nth Fibonacci number
 *
 * @example
 *   fibonacci(10) // 55
 *   fibonacci(0) // 0
 *   fibonacci(1) // 1
 */
fn fibonacci(n: Int) -> Int = {
    if n < 0 {
        0
    } else {
        if n == 0 {
            0
        } else {
            if n == 1 {
                1
            } else {
                let mut a = 0;
                let mut b = 1;
                let mut i = 2;
                while i <= n {
                    let temp = a + b;
                    a = b;
                    b = temp;
                    i = i + 1
                };
                b
            }
        }
    }
}

/**
 * Checks if a number is even.
 *
 * @param n The integer to check
 * @return true if even, false otherwise
 *
 * @example
 *   isEven(4) // true
 *   isEven(5) // false
 */
fn isEven(n: Int) -> Int = if n % 2 == 0 { 1 } else { 0 }

/**
 * Checks if a number is odd.
 *
 * @param n The integer to check
 * @return true if odd, false otherwise
 *
 * @example
 *   isOdd(4) // false
 *   isOdd(5) // true
 */
fn isOdd(n: Int) -> Int = if n % 2 != 0 { 1 } else { 0 }

/**
 * Computes the sum of integers from 1 to n using the formula n*(n+1)/2.
 *
 * @param n The upper bound
 * @return Sum of 1 + 2 + ... + n
 *
 * @example
 *   sumTo(10) // 55
 *   sumTo(100) // 5050
 */
fn sumTo(n: Int) -> Int = n * (n + 1) / 2

/**
 * Modulo operation that always returns a positive result.
 *
 * @param a The dividend
 * @param b The divisor
 * @return a mod b (always positive)
 *
 * @example
 *   modPositive(-5, 3) // 1
 *   modPositive(5, 3) // 2
 */
fn modPositive(a: Int, b: Int) -> Int = {
    let result = a % b;
    if result < 0 {
        result + abs(b)
    } else {
        result
    }
}