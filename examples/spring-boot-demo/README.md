# Spring Boot Demo (Flylang)

This example demonstrates using a popular Java framework (Spring Boot) from Flylang via standard Java interop:
- Using Java annotations on classes and methods
- Returning/accepting JSON via standard Java libraries
- Path variables and query parameters
- Request body handling
- Structs with JavaBean-style getters for JSON mapping

## Build & Run

```bash
mvn clean compile
mvn spring-boot:run
```

## Endpoints

### GET /hello
Returns a simple greeting message.

```bash
curl http://localhost:8080/hello
# Response: "Hello from Flylang + Spring Boot"
```

### GET /users/{id}?greet={name}
Returns a JSON User object with the provided id and name.

```bash
curl 'http://localhost:8080/users/123?greet=Alice'
# Response: {"id":"123","name":"Alice"}
```

### POST /users
Accepts a JSON User object and returns it with "_created" suffix.

```bash
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"id":"456","name":"Bob"}'
# Response: {"id":"456","name":"Bob_created"}
```

## Source Layout

- `src/main/firefly/com/example/Application.fly` - Main application with Spring Boot configuration and REST controllers
- `src/main/firefly/firefly/std/net/net.fly` - Network utilities (optional)

## Key Flylang Features Demonstrated

### 1. Spring Annotations

Flylang supports Java annotations naturally:

```fly
@SpringBootApplication
class Application {
    pub fn fly(args: [String]) -> Void {
        SpringApplication::run(Application.class);
    }
}

@RestController
class HelloController {
    @GetMapping("/hello")
    pub fn hello() -> String {
        "Hello from Flylang + Spring Boot"
    }
}
```

### 2. Structs with JSON Support

Structs automatically generate:
- JavaBean-style getters (`getId()`, `getName()`)
- Constructor with parameter names in bytecode for Jackson
- `equals()`, `hashCode()`, and `toString()` methods

```fly
struct User {
    id: String,
    name: String
}
```

### 3. Parameter Annotations

Path variables, query parameters, and request bodies work seamlessly:

```fly
@GetMapping("/users/{id}")
pub fn getUser(
    @PathVariable("id") id: String,
    @RequestParam("greet") greet: String
) -> User {
    User { id: id, name: greet }
}

@PostMapping("/users")
pub fn createUser(@RequestBody body: User) -> User {
    User { id: body.id, name: body.name + "_created" }
}
```

## Implementation Notes

### Jackson Integration

The Flylang compiler generates:
- JavaBean getters for all struct fields
- Constructor parameter names in bytecode (via `MethodParameters` attribute)
- This allows Jackson to deserialize JSON without `@JsonProperty` annotations

### Spring Annotation Arrays

Spring mapping annotations like `@GetMapping` expect `String[]` for the `value` attribute. The compiler automatically wraps single string values in arrays when emitting annotation bytecode.

### Static Method Calls

Flylang uses `::` for static method calls:
```fly
SpringApplication::run(Application.class);
```

When passing multiple arguments to static methods, complex expressions (like `Application.class`) should be used as single arguments or assigned to variables first.

## Dependencies

The project includes:
- `spring-boot-starter-web` (3.2.0) - Web framework and embedded Tomcat
- `jackson-module-parameter-names` - Enables Jackson to read constructor parameter names from bytecode
- `firefly-maven-plugin` (1.0-Alpha) - Compiles `.fly` files to JVM bytecode

## Troubleshooting

If you encounter issues:

1. **Ensure Java 21+**: `java -version`
2. **Clean build**: `mvn clean install -DskipTests` in the parent `firefly-lang` directory first
3. **Check compilation**: Look for `.class` files in `target/classes/com/example/`
4. **Verify bytecode**: Use `javap -v target/classes/com/example/User.class` to inspect generated bytecode
