# Java Interoperability in Firefly

## Overview

Firefly compiles directly to **JVM bytecode** (Java 21 target), which means it has native Java interoperability built-in. Every Firefly program runs on the JVM and can interact with Java code seamlessly.

## Current Status (v0.1.0)

### ‚úÖ Working Features

#### 1. Built-in Functions Call Java Methods

All Firefly built-in functions are implemented as direct Java method calls:

| Firefly Function | Java Implementation |
|-----------------|---------------------|
| `println(String)` | `System.out.println(String)` |
| `print(String)` | `System.out.print(String)` |
| `toString(Any)` | `String.valueOf(Object)` |
| `error(String)` | `throw new RuntimeException(String)` |

**Example:**
```firefly
fn main() {
    println("Hello from Firefly!");  // Calls System.out.println()
}
```

#### 2. JVM Bytecode Generation

Firefly generates standard Java bytecode that:
- Uses the **Java 21 class file format**
- Follows JVM verification rules
- Can be executed by any JVM
- Can be decompiled to see Java equivalents

**Verify bytecode:**
```bash
# Compile Firefly
java -jar firefly-cli.jar compile program.fly

# Inspect with javap
javap -c -p Main.class
```

#### 3. Type Mapping

Firefly types map directly to JVM types:

| Firefly Type | JVM Type | Java Type |
|-------------|----------|-----------|
| `Int` | `I` | `int` |
| `Float` | `F` | `float` |
| `Bool` | `Z` | `boolean` |
| `String` | `Ljava/lang/String;` | `java.lang.String` |
| `Unit` | `V` | `void` |

**Example:**
```firefly
fn add(a: Int, b: Int) -> Int {
    a + b
}
```

Generates bytecode equivalent to:
```java
public static int add(int a, int b) {
    return a + b;
}
```

### ‚è≥ Coming in v0.2.0+

The following advanced Java interop features are planned:

| Feature | Status | ETA |
|---------|--------|-----|
| `import` statements | ‚è≥ Parsed only | v0.2.0 |
| `new` keyword | ‚è≥ Planned | v0.2.0 |
| Method calls (`.method()`) | ‚è≥ Planned | v0.2.0 |
| Java generics | ‚è≥ Planned | v0.3.0 |
| Annotations | ‚è≥ Planned | v0.3.0 |
| Implementing Java interfaces | ‚è≥ Planned | v0.4.0 |
| Calling from Java to Firefly | ‚úÖ Works now | v0.1.0 |

## How It Works

### Compilation Process

```
Firefly Source (.fly)
      ‚Üì
   ANTLR Parser
      ‚Üì
   AST Builder
      ‚Üì
Type Checker & Semantic Analysis
      ‚Üì
Bytecode Generator (ASM library)
      ‚Üì
JVM Bytecode (.class)
      ‚Üì
   Java Runtime
```

### Example: Behind the Scenes

**Firefly code:**
```firefly
fn greet(name: String) {
    println("Hello, " + name)
}

fn main() {
    greet("Firefly")
}
```

**Generated bytecode (pseudo-Java):**
```java
public class Main {
    public static void greet(String name) {
        System.out.println("Hello, " + name);
    }
    
    public static void main(String[] args) {
        greet("Firefly");
    }
}
```

## Calling Firefly from Java

Since Firefly compiles to standard JVM classes, you can call Firefly code from Java:

**Firefly (Math.fly):**
```firefly
package examples

fn factorial(n: Int) -> Int {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}
```

**Java caller:**
```java
public class JavaCaller {
    public static void main(String[] args) {
        // Call Firefly function
        int result = examples.Math.factorial(5);
        System.out.println("5! = " + result);  // Prints: 5! = 120
    }
}
```

**Compile and run:**
```bash
# Compile Firefly
java -jar firefly-cli.jar compile Math.fly

# Compile Java (assuming Math.class is in examples/)
javac -cp examples/ JavaCaller.java

# Run
java -cp .:examples/ JavaCaller
```

## Examples

### 1. Simple Output (v0.1.0)

See: `examples/java-interop/SimpleJavaInterop.fly`

```firefly
fn main() {
    println("=== Java Interop Demo ===");
    println("All built-in functions use Java!");
    println("Firefly compiles to JVM bytecode.")
}
```

**Run:**
```bash
java -jar firefly-cli.jar run examples/java-interop/SimpleJavaInterop.fly
```

**Output:**
```
=== Java Interop Demo ===
All built-in functions use Java!
Firefly compiles to JVM bytecode.
```

### 2. Advanced Example (Coming in v0.2.0)

This example will work in future versions:

```firefly
import java.util.ArrayList
import java.time.LocalDateTime

fn main() {
    // Create Java ArrayList
    let list = new ArrayList<String>();
    list.add("Firefly");
    list.add("rocks!");
    
    // Use Java time API
    let now = LocalDateTime.now();
    let year = now.getYear();
    
    println("Year: " + year);
    println("List size: " + list.size())
}
```

## Inspecting Generated Bytecode

### Using javap

```bash
# Compile Firefly program
java -jar firefly-cli.jar compile hello.fly

# Disassemble with javap
javap -c -p Main.class
```

**Example output:**
```
public class Main {
  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2    // String Hello, Firefly!
       2: invokestatic  #3    // Method println:(Ljava/lang/String;)V
       5: return
}
```

### Using jd-gui (GUI Decompiler)

1. Download [JD-GUI](http://java-decompiler.github.io/)
2. Open the generated `.class` file
3. See Java-equivalent code

## Runtime Dependencies

Firefly programs only require:
- **Java 21+** JVM
- No additional runtime libraries (v0.1.0)
- Future versions may include `firefly-runtime.jar`

## Performance

Since Firefly compiles to native JVM bytecode:
- ‚úÖ No interpretation overhead
- ‚úÖ JIT compilation by HotSpot
- ‚úÖ Same performance as handwritten Java
- ‚úÖ Access to all JVM optimizations

## Limitations (v0.1.0)

1. **No direct Java class instantiation** - Use built-ins only
2. **No method calls** - Functions only
3. **No import statements** - Core types only
4. **No generics** - Basic types only
5. **No annotations** - Planned for Spring Boot support

These will be addressed in upcoming releases.

## Best Practices

### 1. Use Firefly's Type System

```firefly
// ‚úÖ Good - uses Firefly types
fn calculate(x: Int) -> Int {
    x * 2
}

// ‚ùå Don't try to use Java syntax
// fn calculate(x: java.lang.Integer) -> Integer  // Won't work yet
```

### 2. Trust the Compiler

The Firefly compiler generates correct JVM bytecode. You don't need to think about Java when writing Firefly.

### 3. Leverage Built-in Functions

```firefly
// ‚úÖ Good
println("Debug: " + x);

// ‚ùå Don't try to call Java directly (yet)
// System.out.println("Debug: " + x);  // Won't work in v0.1.0
```

## Future Roadmap

### v0.2.0 - Basic Interop
- Import Java classes
- Call Java methods
- Create Java objects (`new`)

### v0.3.0 - Advanced Interop
- Java generics support
- Implement Java interfaces
- Annotations

### v0.4.0 - Full Interop
- Bidirectional calls (Java ‚Üî Firefly)
- Reflection support
- Full standard library

### v0.5.0 - Spring Boot
- Spring annotations
- Dependency injection
- REST API support
- JPA integration

## Resources

- **ASM Library**: Used for bytecode generation
- **ANTLR4**: Parser generator
- **JVM Spec**: https://docs.oracle.com/javase/specs/jvms/se21/html/
- **Firefly Examples**: `examples/` directory

## Summary

‚úÖ **Firefly v0.1.0 has native Java interop through JVM bytecode generation**

Every Firefly program:
- Compiles to standard JVM `.class` files
- Can be called from Java
- Uses Java methods internally (println, etc.)
- Runs on any Java 21+ JVM

Advanced interop features (imports, method calls, etc.) are coming in v0.2+!

---

**Made with üî• by the Firefly Team**
